#!/usr/bin/env python


# this script is used to generate the waveform table and
# the phase increments.

# ./make_tables.py > firmware/... tables.inc

# http://www.phy.mtu.edu/~suits/scales.html

from math import sin, pi, cos
from bitstring import BitArray

table_size = 256

phase_counter_max = 2**16 - 1
fmaster = 5e4
fmax = fmaster / 2


print "; table definitons for picophone"
print "; generated by make_tables.py"
print 

# base frequncies for the fourth piano octave
c = 261.626
cis = des = 277.183
d = 293.665
dis = es = 311.127
e = 329.682
f = 349.228
fis = ges = 369.994
g = 391.995
gis = as_ = 415.305
a = 440
ais = b = 466.164
h = 493.883

( unison,         # 1
    sec_min,      # 2
    sec_maj,      # 3
    third_min,    # 4
    third_maj,    # 5
    fourth,       # 6
    fifth_dim,    # 7
    fifth,        # 8
    sixth_min,    # 9
    sixth_maj,    # 10
    seven_min,    # 11
    seven_maj,    # 12
    octave        # 13
    ) = range(13)

temp_just1 = [
    1,        # 1  unison
    25./24.,  # 2  minor second
    9./8.,    # 3  major second
    6./5.,    # 4  minor third
    5./4.,    # 5  major third
    4./3.,    # 6  fourth
    45./32.,  # 7  diminished fith
    3./2.,    # 8  fifth
    8./5.,    # 9  minor sixth
    5./3.,    # 10 major sixth
    9./5.,    # 11 minor seventh
    15./8.,   # 12 major seventh,
    2.        # 13 octave
    ]

temp_equ = [ (2. ** (1./12.)) ** (t) for t in range (13) ]

def make_freq(base, scale, temp):
  temp_2_oct = [ temp[s] for s in [unison] + scale ] + [ 2.*temp[s] for s in [unison] + scale + [octave] ]
  return [ base * t for t in temp_2_oct ]


# scales:
# unison and octave are implied

# blues major
scale_bl = [sec_maj, third_min, third_maj, fifth, sixth_maj, seven_min] 

# blues minor
scale_bl_min = [third_min, fourth, fifth_dim, fifth, seven_min]

# major
scale_maj = [sec_maj, third_maj, fourth, fifth, sixth_maj, seven_maj]

# minor pure
scale_min_p = [ sec_maj, third_min, fourth, fifth, sixth_min, seven_min]

# minor melodic
scale_min_m1 = [ sec_maj, third_min, fourth, fifth, sixth_maj, seven_maj]
scale_min_m2 = [ sec_maj, third_min, fourth, fifth, sixth_min, seven_min]

# minor harmonic
scale_min_h = [ sec_maj, third_min, fourth, fifth, sixth_min, seven_maj]

# zigeuner
scale_gyp = [ sec_maj, third_min, fifth_dim, fifth, sixth_min, seven_maj]



# generate frequencies for that scale & temper
fs = make_freq(c, scale_bl, temp_just1)

print 
print "; gypsy scale in C4 for just temper"
print 

# shift octave
fs = [ f/2.0 for f in fs ]




phases_incr = [ int(round(phase_counter_max / (fmax / f)))  for f in fs]

format_lo = lambda c: "0x" + BitArray(uint=c, length=16).hex[2:4]
format_hi = lambda c: "0x" + BitArray(uint=c, length=16).hex[0:2]

print "; values for a master clock of %d Hz" %(fmaster,)
print 
print "; needs to be in first page -> include early"
print "; addwf PCL needs that"
print "; unsigned 8 bit values, one for lo-byte and one for hi-byte"
print "TABLE_ph_incr_lo"
print "	addwf PCL,F"
print "	dt	" + ",".join([ format_lo(c) for c in phases_incr  ])
print 

print "TABLE_ph_incr_hi"
print "	addwf PCL,F"
print "	dt	" + ",".join([ format_hi(c) for c in phases_incr  ])
print






# generate waveform
# waveform is stored as 8 bit signed

sin_codes = [ sin(2.0*pi*i / table_size) for i in range(table_size) ]
sqr_codes = [ i < table_size/2 and 1 or -1 for i in range(table_size) ]
tri_codes = [ (2.* float(i)/table_size)-1. for i in range(table_size) ]

codes = [ int( 120 * x ) for x in tri_codes ]
format = lambda c: "0x" + BitArray(int=c, length=8).hex


print "TABLE_waveform"
print "	; 8 bit signed values"
print "	; table lookup code for large tables:"
print "	movwf taboff"
print "	bcf STATUS,C"
print "	rlcf taboff,F"
print "	movlw HIGH(TABLE_START_wavetable)"
print "	btfsc STATUS,C"
print "	incf WREG,W"
print "	movwf PCLATH"
print "	movlw LOW(TABLE_START_wavetable)"
print "	addwf taboff,W"
print "	btfsc STATUS,C"
print "	incf PCLATH,F"
print "	movwf PCL"
print "TABLE_START_wavetable"

step = 8
for i in range(table_size/step):
  #print i, i*8, (i+1)*8
  print "	dt	" + ",".join([format(c) for c in codes[i*8 : (i+1)*8] ])
print


